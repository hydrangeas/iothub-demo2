# MachineLog.Collector

MachineLog.Collectorは.NET 8.0ベースのWorker Serviceで、産業機器からのログファイルを監視・収集し、IoT HubのUploadModuleLogsを使用してBlobストレージにアップロードします。

## ファイル監視

- FileSystemWatcherを使用して新規ログファイルを検出
- 複数のディレクトリを同時に監視（最大10ディレクトリまで）
- ファイル作成・変更イベントをハンドリング
- 安定したファイルのみを処理（書き込み完了後、デフォルト待機時間: 5秒）
- 監視対象ファイル拡張子: .log, .json, .jsonl

## ログファイル形式

- JSON Lines形式（1行1JSONオブジェクト）
- 1行あたり最大16KB
- 必須フィールド：MachineId, TimeGenerated, Severity, EventId, Message, OperationId, Tags
  - MachineId: 英数字とハイフンのみ、最大50文字
  - TimeGenerated: ISO 8601形式（yyyy-MM-ddTHH:mm:ss.fffZ）
  - Severity: "Debug", "Info", "Warning", "Error", "Critical"のいずれか
  - EventId: 1〜999999の整数
  - Message: 最大8000文字
  - OperationId: UUID形式
  - Tags: キーと値のペア、最大10ペアまで
- エンコーディング：UTF-8（BOMなし）
- 有効なJSON形式であることを検証

## バッチ処理

- 複数のログエントリをバッチとして処理
- バッチサイズは最大1MB
- 1バッチあたり最大10,000エントリ
- バッチ処理間隔: 設定可能（デフォルト30秒）
- 効率的なネットワーク利用とスループット最適化
- バッチ処理の進捗状況を追跡（処理済みエントリ数、残りエントリ数）

## ファイル保持ポリシー

- 処理済みファイルの保持期間を設定可能
- デフォルトでは50MB以上のファイルは7日間保持、それ以下は30日間保持
- 古いファイルは自動的に圧縮（gzip形式）または削除
- ディスク容量の効率的な管理（使用可能容量が20%を下回ると警告）
- アーカイブディレクトリのパスを設定可能

## 非同期処理

- I/O操作とAPI呼び出しは非同期で実行
- asyncとawaitパターンを適切に使用
- 長時間実行タスクはTask.Runで実行
- CancellationTokenによる処理の適切な中断
- IAsyncEnumerableによる効率的なストリーム処理
- ConfigureAwait(false)の適切な使用

## 並行処理

- スレッドセーフな操作を保証
- ConcurrentQueue, ConcurrentDictionaryの活用
- SemaphoreSlim, lockによる同期
- デッドロックの回避
- レースコンディションの防止
- 並行処理の最大数を設定可能（デフォルト: 環境のプロセッサ数）

## リソース管理

- IDisposableを実装しDispose()メソッドで適切にリソースを解放
- usingステートメントまたはusingブロックの活用
- メモリリークの防止
- IAsyncDisposableの実装
- ファイナライザの適切な実装
- メモリ使用量の監視と制限（最大使用メモリ: 設定可能、デフォルト1GB）

## エラーハンドリング

- 構造化された例外処理
- リトライメカニズムの実装（指数バックオフ、最大5回）
- 詳細なエラーログ（例外スタックトレース、コンテキスト情報を含む）
- グレースフルデグラデーション
- 自動復旧メカニズム
- 致命的エラー発生時の通知機能（メール、Webhook）
- カスタム例外クラスの実装（例: LogProcessingException, NetworkException）
- エラー発生時のトランザクション管理（ロールバック機能）

## セキュリティ対策

- すべての通信にTLS 1.3を使用
- 認証情報の安全な管理（Azure Key Vaultの利用）
- 入力データのサニタイズ処理
- OWASP Top 10に基づくセキュリティ対策の実装
- 定期的なセキュリティ監査の実施
- ログデータの暗号化（AES-256）

## パフォーマンス最適化

- ホットパスの最適化（プロファイリングツールを使用）
- メモリプーリングの実装（ArrayPool<T>の活用）
- 効率的なJSONシリアライズ/デシリアライズ（System.Text.Json.Utf8JsonReaderの使用）
- バッチ処理のチューニング（最適なバッチサイズの動的調整）
- 非同期I/Oの最大化
- キャッシュ戦略の実装（メモリキャッシュ、分散キャッシュの活用）

## テスト戦略

- 単体テスト（xUnit.netを使用、カバレッジ90%以上）
- 統合テスト（実際のAzureリソースを使用）
- パフォーマンステスト（負荷テスト、スケーラビリティテスト）
- セキュリティテスト（脆弱性スキャン、ペネトレーションテスト）
- エンドツーエンドテスト（実際の機器を模擬したシミュレーション）
- カオスエンジニアリングテスト（障害注入テスト）

## 監視とテレメトリ

- 詳細な操作ログ（構造化ログ形式）
- パフォーマンスメトリックの収集（CPU使用率、メモリ使用量、処理速度）
- ヘルスチェックエンドポイントの提供（/health）
- Application Insightsとの統合
- カスタムメトリクスの出力（処理ファイル数、エラー率、平均処理時間）
- アラート閾値の設定
- リアルタイムダッシュボードの実装（Azure Monitorとの連携）

## Claude 3.7 Sonnetとの互換性

- 非同期処理モデルの完全サポート
- 効率的なメモリ管理
- 高速な起動時間の確保（Cold Start最適化）
- コンテナ化対応（Docker/Kubernetes互換）
- 適切なスケーリング特性
- マイクロサービスアーキテクチャへの適合性

## コード品質とベストプラクティス

- 単体テストカバレッジ90%以上
- 統合テストによる主要フロー検証
- コードスタイルの一貫性（.editorconfig準拠）
- ドキュメント化されたパブリックAPI
- セキュリティベストプラクティスの遵守
- パフォーマンス最適化（ホットパス特定）
- コードレビューの義務化（最低2名のレビュアー）
- 静的コード分析ツールの使用（例: ReSharper, SonarQube）
- 定期的なコードリファクタリングの実施
